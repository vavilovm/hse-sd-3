# CLI

## Схема архитектуры

![Architecture](architecture.png)

## **Main App**
Класс, отвечающий за связывание компонент приложения и взаимодействие с пользователем. Содержит в себе следующие компоненты:
* `Memory` -- хранит переменные окружения
* `Parser` -- разбивает введеную строку на токены
* `Formatter` -- подставляет в токены значения переменных из `Memory`, склеивает токены, разбивает последовательность токенов на элементы пайпа
* `Command Factory` -- выдает список комманд, построенный на основе входа
* `Executor` -- запускает выполнение пайпа
* `Reader` -- читает пользовательского ввода
* `Writer` -- пишет в stdout и stderr

Методы:
* `start` -- запускает приложение

В методе `start` выполняется бесконечный цикл. На каждой итерации с помощью `Reader` считывается введенная пользовотелем строка. Далее эта строка передается в `Parser`, котороый выдает список токенов. Список токенов идет на вход `Formater`, который подставляет в токены переменные окружения, склеивает токены, если между ними нет пробела (пример с exit из презентации), разбивает на группы по символу `|` в качестве разделителя. Полученные группы токенов подаются `Command Factory`, которая на их основе создает потомков класса `Command`. Далее последовательность комманд обрабатывается с помощью `Executor`, ответственного за запуск каждой команды и передачу данных между ними. После этого `Writer` выводит в stdout результат выполнения, если такой имеется, выводит ошибки, если таковые возникли на предыдущих шагах. На этом итерация цикла заканчивается. Выполнение команды `exit` прерывает цикл, информация об этом берется из `Executor` по окончании его работы.

## **Memory**
Представляет из себя класс ответсвенный за хранение переменных окружения.

Поля:
* `data` -- хеш-таблица, хранящая по имени переменной ее значение

Методы:
* `hasValue(name)` -- возвращает информацию о том, есть ли переменная `name`
* `getValue(name)` -- возвращает значение переменной `name`
* `setValue(name, value)` -- добавляет или обновляет переменную с именем `name`, используя значение `value`

При инициализации класса создается хеш-таблица, которая заполняется переменными внешнего окружения (например, с помощью `os.environ` в Python)

## **Parser**
Класс ответсвенный за разбиение входной строки на токены.

Методы:
* `split(string)` -- разбивает строку `string` на токены и возвращает список из них

Правила разбиения:
1. Каждый пробельный символ это отдельный токен
2. `|`, `=` отдельные токен (если вне кавычек)
3. Текст внутри `"` (включительно) ялвляется единым токеном, игнорируется сочетание `\"` и предыдущие правила. Это правило работает, если `"` не находится между `'`
4. Для `'` правила аналогичны правилам из предыдущего пункта
5. `$` и следующая за ним строка (до обозначенных ранее токенов или `$`) считается отдельным токеном

(В теории токены можно обернуть в дополнительный класс, чтоб далее их проще различать, но непонятно на сколько это оправданно, пока обходимся строками)

## **Formatter**
Класс, отвечающий за форматирование последовательности токенов и разбиение их на комманды

Методы:
* `process(tokens, memory)` -- сначала проходится по всем токенам и для каждого токена, начинающегося с `$`, заменяет его на значение из `memory`, для каждого токена, начинающегося с `"` проходится по внутренности и делает аналогичные подстановки с `$`, если токен это `=`, то считаем присваивание корректным лишь если нам подали 3 токена на вход, при этом справа и слева некоторая строка, в противном случае кидаем исключение (разрешаем одно присваивание и только его за одну комманду пользователя для простоты). Если во время подстановки оказывается, что нужной переменной нет, то кидается исключение, сообщающее об этом. Параллельно с проходом подстановки можно бить токены по группам, используя в качестве разделителя `|`, если токены `|` идут подряд, то кидается исключение, говорящее об ошибке. Затем по каждой группе идет еще один проход, объединяющий токены, между которыми не было пробела (пример с exit из презентации), кроме того пробельные токены исключаются за дальнейшей ненадобностью

## **Command**
Интерфейс комманд

Поля:
* `returnCode` -- код возврата
* `stdout` -- вывод комманды в стандартный поток вывода
* `stderr` -- вывод в поток ошибок

Методы:
* `execute(args)` -- выполнение комманды с использование аргументов `args`
* `get*()` -- геттеры соответсвующих полей

Далее перечисленны наследники **Command**

### **CatCommand**
Выводит содержимое файла.

Конструктор ожидает либо 1, либо 0 аргументов

`execute(args)` ожидает 1 аргумент, если он не был передан ранее, в противном случае 0

При успешном выполнении в `stdout` лежит содержимое файла 

### **EchoCommand**
Выводит переданную строку.

Конструктор принимает произвольное количество аргументов

`execute(args)` произвольное количество аргументов

При успешном выполнении в `stdout` лежит строка, являющаяся соединением переданных через пробел

### **WcCommand**
Считает количество строк, слов и байт в файле.

Конструктор ожидает либо 1, либо 0 аргументов

`execute(args)` ожидает 1 аргумент, если он не был передан ранее, в противном случае 0

При успешном выполнении в `stdout` лежит необходимая информация

### **PwdCommand**
Выводит текущую дирректорию.

Конструктор игнорирует аргументы

`execute(args)` игнорирует аргументы

При успешном выполнении в `stdout` лежит текущая дирректория

### **ExitCommand**
Сообщает о завершении программы.

Конструктор игнорирует аргументы

`execute(args)` игнорирует аргументы. Отсюда можно кинуть исключение о завершении (зависит от выбранного языка, в Java так например делать не принято)

`stdout` ничего не содержит 

### **OtherCommand**
Выполняет стороннюю команду

Конструктор принимает один и более аргумент. Первый расценивается как имя команды, которую необходимо выполнить, остально ее аргументы

`execute(args)` аргументы добавляются к тем, что были переданны в конструкторе, зовется соответсвующая команда

`stdout`, `stderr`, `returnCode` хранят соответсвующие значения 

## **Command Factory**
Класс, отвечающий за преобразование предобработанных групп токенов в экземпляры класса `Command`

Методы:
* `tokensToCommands(tokens)` -- для каждой группы токенов понимает присваивание ли это или нет (второй токен `=`), если да, то создает комманду присваивания с соответсвующими аргументами, иначе смотрим на первый токен. Если первый токен это кавычки, то кидаем ошибку. Иначе воспринимаем первый токен как команду, а все последующие токены ее аргументами, конструируем соответсвующий `Command` (если это ни одна из предопределенных комманд, то считаем ее `OtherCommand`). Выдает список комманд

## **Executor**
Класс, отвечающий за последовательное выполнение команд. Содержит переменную `isTerminated`, информирующую о завершении выполнения всей программы.

Методы:
* `execute(commands)` -- идет по каждой комманде и пытается выполнить ее. Если комманда завершается с ошибкой, то останавливает выполнение и возвращает stdout и stderr последней комманды. При усешном выполнении команды берет ее stdout и подает в качестве аргумента следующей команде, либо выдает наружу. Если выполненная комманда оказалось командой `exit`, то обновляет `isTerminated`.
* `isShellTerminated()` -- возвращает значение `isTerminated`.

## **Reader**
Класс, отвечающий за пользовательский ввод

Методы:
* `getLine()` -- выводит пользователю `>>>` и ждет ввода строки, которую возвращает

## **Writer**
Класс, отвечающий за вывод

Методы:
* `printOutputs(stdout, stderr)` -- выводит пользователю строки `stdout` и `stderr`

Можно расширять для перенаправления вывода (если дальше потребуется)

<!-- 
`Main App` object contains `Memory` field for keeping variables values. `Memory` is a key-value storage.

Then the string is parsed by a finite-state machine in `Formatter`, which substitutes variables with their values taken from `Memory`, skipping the substitution in single quotes

The string is passed to the `Parser`, which splits the string into tokens and passes the resulting sequence (syntax tree if we need to support brackets, for now it seems much easier to use a list of commands) to the `Command Factory`.

`Command Factory` creates a descendant of the `Command` class for each element of parsed sequence (or for each nodes of the syntax tree if we use one). Each `Command` object contains `execute` method for perfoming corresponding operation and takes required arguments (e.g. `Cat`'s `execute` method takes name of file and outputs provided file content)

The tree is passed to the `Executor`, which sequentially calls all nodes with the `execute` method using provided arguments, passing the output to the following nodes as their input 

The resulting output or error messages returns to the `Main App`, where it further output to the user. -->

